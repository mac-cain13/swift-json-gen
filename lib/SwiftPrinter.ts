//
// Several functions for generating Swift code based on the parsed AST.
//

var ast = require('./SwiftAst')

function makeFile(file: any[], globalAttrs: GlobalAttrs, filename: string, outputFileExists: boolean): string[] {

  function decoderExists(typeName: string) : boolean {
    return globalAttrs.decoders.contains(typeName);
  }

  function encoderExists(typeName: string) : boolean {
    return globalAttrs.encoders.contains(typeName);
  }

  var structs = ast.structs(file, globalAttrs.typeAliases)
    .filter(s => !decoderExists(s.baseName) || !encoderExists(s.baseName));

  var enums = ast.enums(file, globalAttrs.typeAliases)
    .filter(e => !decoderExists(e.baseName) || !encoderExists(e.baseName));

  // Don't generate a new file when there's no structs/enums
  // (But do overwrite an existing file)
  if (structs.length == 0 && enums.length == 0 && !outputFileExists) {
    return [];
  }

  var lines = [];

  lines.push('//');
  lines.push('//  ' + filename);
  lines.push('//');
  lines.push('//  Auto generated by swift-json-gen on ' + new Date().toUTCString());
  lines.push('//');
  lines.push('');
  lines.push('import Foundation');
  lines.push('');

  enums.forEach(function (s) {

    var createDecoder = !decoderExists(s);
    var createEncoder = !encoderExists(s);

    lines.push('extension ' + s.baseName + ' {')

    if (createDecoder) {
      lines = lines.concat(makeEnumDecoder(s));
    }

    if (createDecoder && createEncoder) {
      lines.push('');
    }

    if (createEncoder) {
      lines = lines.concat(makeEnumEncoder(s));
    }

    lines.push('}');
    lines.push('');
  });

  structs.forEach(function (s) {

    var createDecoder = !decoderExists(s);
    var createEncoder = !encoderExists(s);

    lines.push('extension ' + s.baseName + ' {')

    if (createDecoder) {
      lines = lines.concat(makeStructDecoder(s));
    }

    if (createDecoder && createEncoder) {
      lines.push('');
    }

    if (createEncoder) {
      lines = lines.concat(makeStructEncoder(s));
    }

    lines.push('}');
    lines.push('');
  });

  return lines;
}

exports.makeFile = makeFile;

function makeEnumDecoder(en: Enum) : string {
  var lines = [];

  lines.push('  static func decodeJson(json: AnyObject) -> ' + en.baseName + '? {');
  lines.push('    if let value = json as? ' + en.rawTypeName + ' {');
  lines.push('      return ' + en.baseName + '(rawValue: value)');
  lines.push('    }');
  lines.push('    return nil');
  lines.push('  }');

  return lines.join('\n');
}

function makeEnumEncoder(en: Enum) : string {
  var lines = [];

  lines.push('  func encodeJson() -> AnyObject {');
  lines.push('    return rawValue');
  lines.push('  }');

  return lines.join('\n');
}

function makeStructDecoder(struct: Struct) : string {
  var lines = [];

  lines.push('  static func decodeJson' + decodeArguments(struct) + ' -> ' + struct.baseName + '? {');
  lines.push('    let _dict = json as? [String : AnyObject]');
  lines.push('    if _dict == nil { return nil }');
  lines.push('    let dict = _dict!');
  lines.push('');

  struct.varDecls.forEach(function (d) {
    var subs = makeFieldDecode(d, struct.typeArguments).map(indent(4));
    lines = lines.concat(subs);
  });

  lines = lines.concat(indent(4)(makeReturn(struct)));

  lines.push('  }');

  return lines.join('\n');
}

function makeStructEncoder(struct: Struct) : string {
  var lines = [];
  lines.push('  func encodeJson' + encodeArguments(struct) + ' -> AnyObject {');
  lines.push('    var dict: [String: AnyObject] = [:]');
  lines.push('');

  struct.varDecls.forEach(function (d) {
    var subs = makeFieldEncode(d, struct.typeArguments).map(indent(4));
    lines = lines.concat(subs);
  });

  lines.push('');
  lines.push('    return dict');
  lines.push('  }');

  return lines.join('\n');
}

function decodeArguments(struct: Struct) : string {
  var parts = struct.typeArguments
    .map(t => 'decode' + t + ': AnyObject -> ' + t + '?')

  parts.push('json: AnyObject');

  for (var i = 1; i < parts.length; i++) {
    parts[i] = '_ ' + parts[i];
  }

  return '(' + parts.join(', ') + ')';
}

function encodeArguments(struct: Struct) : string {
  var parts = struct.typeArguments
    .map(t => 'encode' + t + ': ' + t + ' -> AnyObject')

  for (var i = 1; i < parts.length; i++) {
    parts[i] = '_ ' + parts[i];
  }

  return '(' + parts.join(', ') + ')';
}

function indent(nr) {
  return function (s) {
    return s == '' ? s :  Array(nr + 1).join(' ') + s;
  };
}

function isKnownType(type: Type) : boolean {
  var types = [ 'AnyObject', 'AnyJson' ];
  return types.contains(type.alias) || types.contains(type.baseName);
}

function isCastType(type: Type) : boolean {
  var types = [ 'JsonObject', 'JsonArray' ];
  return types.contains(type.alias) || types.contains(type.baseName);
}

function encodeFunction(name: string, type: Type, genericEncoders: string[]) : string {

  if (isKnownType(type))
    return name;

  if (genericEncoders.contains(type.baseName))
    return 'encode' + type.baseName + '(' + name + ')';

  var args = type.genericArguments
    .map(t => '{ ' + encodeFunction('$0', t, genericEncoders) + ' }')
    .join(', ');

  return name + '.encodeJson(' + args + ')';
}

function makeFieldEncode(field: VarDecl, structTypeArguments: string[]) {
  var name = field.name;
  var type = field.type;

  return [ 'dict["' + name + '"] = ' + encodeFunction(name, type, structTypeArguments) ];

  if (isKnownType(type))
    return [ 'dict["' + name + '"] = ' + name ];

  if (structTypeArguments.contains(type.baseName))
    return [ 'dict["' + name + '"] = encode' + type.baseName + '(' + name + ')' ];

  var args = type.genericArguments
    .map(t => '{ $0.encodeJson() }')
    .map(s => '(' + s + ')')
    .join('');

  return [ 'dict["' + name + '"] = ' + name + '.encodeJson' + args + '()' ];
}

function decodeFunction(arg: string, type: Type, genericDecoders: string[]) : string {
  var args = type.genericArguments
    .map(a => decodeFunctionArgument(a, genericDecoders))
    .concat([ arg ])
    .join(', ');

  var typeName = type.alias || type.baseName;

  if (isKnownType(type))
    return '{ $0 as ' + typeName + ' }';

  if (isCastType(type))
    return '{ $0 as? ' + typeName + ' }';

  if (genericDecoders.contains(typeName))
    return 'decode' + typeName + '(' + args + ')'

  return typeName + '.decodeJson(' + args + ')';
}

function decodeFunctionArgument(type: Type, genericDecoders: string[]) : string {

  var typeName = type.alias || type.baseName;

  if (isKnownType(type))
    return '{ $0 as ' + typeName + ' }';

  if (isCastType(type))
    return '{ $0 as? ' + typeName + ' }';

  return '{ ' + decodeFunction('$0', type, genericDecoders) + ' }'
}

function typeToString(type: Type) : string {
  if (type.genericArguments.length == 0)
    return type.baseName;

  if (type.baseName == 'Optional')
    return typeToString(type.genericArguments[0]) + '?';

  if (type.baseName == 'Array')
    return '[' + typeToString(type.genericArguments[0]) + ']';

  if (type.baseName == 'Dictionary')
    return '[' + typeToString(type.genericArguments[0]) + ' : ' + typeToString(type.genericArguments[1]) + ']';

  var args = type.genericArguments.map(typeToString).join(', ')
  return type.baseName + '<' + args + '>';
}

function makeFieldDecode(field: VarDecl, structTypeArguments: string[]) {
  var name = field.name;
  var type = field.type;
  var fieldName = name + '_field';
  var optionalName = name + '_optional';
  var typeString = typeToString(type);

  var lines = [
    'let ' + fieldName + ': AnyObject? = dict["' + name + '"]',
  ];

  if (type.baseName == 'Optional') {
    lines.push('let ' + name + ': ' + typeString + ' = ' + fieldName + ' == nil ? nil : ' + decodeFunction(fieldName + '!', type, structTypeArguments))
  }
  else {
    lines.push('if ' + fieldName + ' == nil { assertionFailure("field \'' + name + '\' is missing"); return nil }');

    if (isKnownType(type)) {
      lines.push('let ' + name + ': ' + typeString + ' = ' + fieldName + '!');
    }
    else if (isCastType(type)) {
      lines.push('let ' + optionalName + ': ' + typeString + '? = ' + fieldName + '! as? ' + typeString)
      lines.push('if ' + optionalName + ' == nil { assertionFailure("field \'' + name + '\' is not ' + typeString + '"); return nil }');
      lines.push('let ' + name + ': ' + typeString + ' = ' + optionalName + '!');
    }
    else {
      lines.push('let ' + optionalName + ': ' + typeString + '? = ' + decodeFunction(fieldName + '!', type, structTypeArguments))
      lines.push('if ' + optionalName + ' == nil { assertionFailure("field \'' + name + '\' is not ' + typeString + '"); return nil }');
      lines.push('let ' + name + ': ' + typeString + ' = ' + optionalName + '!');
    }
  }

  lines.push('');

  return lines;
}

function makeReturn(struct: Struct) {
  var params = struct.varDecls.map(decl => decl.name + ': ' + decl.name);

  return 'return ' + struct.baseName + '(' + params.join(', ') + ')'
}

