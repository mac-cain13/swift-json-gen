//
// Several functions for generating Swift code based on the parsed AST.
//

var ast = require('./SwiftAst')

function makeFile(file: any[], globalAttrs: GlobalAttrs, filename: string, outputFileExists: boolean): string[] {

  function decoderExists(struct: Struct) : boolean {
    return globalAttrs.decoders.contains(struct.baseName);
  }

  function encoderExists(struct: Struct) : boolean {
    return globalAttrs.encoders.contains(struct.baseName);
  }

  var structs = ast.structs(file, globalAttrs.typeAliases)
    .filter(s => !decoderExists(s) || !encoderExists(s));

  // Don't generate a new file when there's no structs
  // (But do overwrite an existing file)
  if (structs.length == 0 && !outputFileExists) {
    return [];
  }

  var lines = [];

  lines.push('//');
  lines.push('//  ' + filename);
  lines.push('//');
  lines.push('//  Auto generated by swift-json-gen on ' + new Date().toUTCString());
  lines.push('//');
  lines.push('');
  lines.push('import Foundation');
  lines.push('');

  structs.forEach(function (s) {
    lines = lines.concat(makeExtension(s, !decoderExists(s), !encoderExists(s)));
    lines.push('');
  });

  return lines;
}

exports.makeFile = makeFile;

function makeExtension(struct: Struct, createDecoder: boolean, createEncoder: boolean) : string {

  var lines = [];

  lines.push('extension ' + struct.baseName + ' {')

  if (createDecoder) {
    lines.push('  static func decodeJson' + decodeArguments(struct) + ' -> ' + struct.baseName + '? {');
    lines.push('    guard let dict = json as? [String : AnyObject] else {');
    lines.push('      assertionFailure("json not a dictionary");');
    lines.push('      return nil');
    lines.push('    }');
    lines.push('');

    struct.varDecls.forEach(function (d) {
      var subs = makeFieldDecode(d, struct.typeArguments).map(indent(4));
      lines = lines.concat(subs);
    });

    lines = lines.concat(indent(4)(makeReturn(struct)));

    lines.push('  }');
  }

  if (createDecoder && createEncoder) {
    lines.push('');
  }

  // encoder
  if (createEncoder) {
    lines.push('  func encodeJson' + encodeArguments(struct) + ' -> AnyObject {');
    lines.push('    var dict: [String: AnyObject] = [:]');
    lines.push('');

    struct.varDecls.forEach(function (d) {
      var subs = makeFieldEncode(d, struct.typeArguments).map(indent(4));
      lines = lines.concat(subs);
    });

    lines.push('');
    lines.push('    return dict');
    lines.push('  }');
  }

  lines.push('}');

  return lines.join('\n');
}

function decodeArguments(struct: Struct) : string {
  var parts = struct.typeArguments
    .map(t => 'decode' + t + ': AnyObject -> ' + t + '?')

  parts.push('json: AnyObject');

  for (var i = 1; i < parts.length; i++) {
    parts[i] = '_ ' + parts[i];
  }

  return '(' + parts.join(', ') + ')';
}

function encodeArguments(struct: Struct) : string {
  var parts = struct.typeArguments
    .map(t => 'encode' + t + ': ' + t + ' -> AnyObject')

  for (var i = 1; i < parts.length; i++) {
    parts[i] = '_ ' + parts[i];
  }

  return '(' + parts.join(', ') + ')';
}

function indent(nr) {
  return function (s) {
    return s == '' ? s :  Array(nr + 1).join(' ') + s;
  };
}

function isKnownType(type: Type) : boolean {
  var types = [ 'AnyObject', 'AnyJson' ];
  return types.contains(type.alias) || types.contains(type.baseName);
}

function isCastType(type: Type) : boolean {
  var types = [ 'JsonObject', 'JsonArray' ];
  return types.contains(type.alias) || types.contains(type.baseName);
}

function encodeFunction(name: string, type: Type, genericEncoders: string[]) : string {

  if (isKnownType(type))
    return name;

  if (genericEncoders.contains(type.baseName))
    return 'encode' + type.baseName + '(' + name + ')';

  var args = type.genericArguments
    .map(t => '{ ' + encodeFunction('$0', t, genericEncoders) + ' }')
    .join(', ');

  return name + '.encodeJson(' + args + ')';
}

function makeFieldEncode(field: VarDecl, structTypeArguments: string[]) {
  var name = field.name;
  var type = field.type;

  return [ 'dict["' + name + '"] = ' + encodeFunction(name, type, structTypeArguments) ];

  if (isKnownType(type))
    return [ 'dict["' + name + '"] = ' + name ];

  if (structTypeArguments.contains(type.baseName))
    return [ 'dict["' + name + '"] = encode' + type.baseName + '(' + name + ')' ];

  var args = type.genericArguments
    .map(t => '{ $0.encodeJson() }')
    .map(s => '(' + s + ')')
    .join('');

  return [ 'dict["' + name + '"] = ' + name + '.encodeJson' + args + '()' ];
}

function decodeFunction(arg: string, type: Type, genericDecoders: string[]) : string {
  var args = type.genericArguments
    .map(a => decodeFunctionArgument(a, genericDecoders))
    .concat([ arg ])
    .join(', ');

  var typeName = type.alias || type.baseName;

  if (isKnownType(type))
    return '{ $0 as ' + typeName + ' }';

  if (isCastType(type))
    return '{ $0 as? ' + typeName + ' }';

  if (genericDecoders.contains(typeName))
    return 'decode' + typeName + '(' + args + ')'

  return typeName + '.decodeJson(' + args + ')';
}

function decodeFunctionArgument(type: Type, genericDecoders: string[]) : string {

  var typeName = type.alias || type.baseName;

  if (isKnownType(type))
    return '{ $0 as ' + typeName + ' }';

  if (isCastType(type))
    return '{ $0 as? ' + typeName + ' }';

  return '{ ' + decodeFunction('$0', type, genericDecoders) + ' }'
}

function typeToString(type: Type) : string {
  if (type.genericArguments.length == 0)
    return type.baseName;

  if (type.baseName == 'Optional')
    return typeToString(type.genericArguments[0]) + '?';

  if (type.baseName == 'Array')
    return '[' + typeToString(type.genericArguments[0]) + ']';

  if (type.baseName == 'Dictionary')
    return '[' + typeToString(type.genericArguments[0]) + ' : ' + typeToString(type.genericArguments[1]) + ']';

  var args = type.genericArguments.map(typeToString).join(', ')
  return type.baseName + '<' + args + '>';
}

function makeFieldDecode(field: VarDecl, structTypeArguments: string[]) {
  var name = field.name;
  var type = field.type;
  var fieldName = name + '_field';
  var optionalName = name + '_optional';
  var typeString = typeToString(type);

  var lines = [];

  if (type.baseName == 'Optional') {
    lines.push('let ' + fieldName + ': AnyObject? = dict["' + name + '"]');
    lines.push('let ' + name + ': ' + typeString + ' = ' + fieldName + ' == nil ? nil : ' + decodeFunction(fieldName + '!', type, structTypeArguments))
  }
  else {
    lines.push('guard let ' + fieldName + ': AnyObject? = dict["' + name + '"] else {');
    lines.push('  assertionFailure("field \'' + name + '\' is missing")');
    lines.push('  return nil');
    lines.push('}');

    if (isKnownType(type)) {
      lines.push('let ' + name + ': ' + typeString + ' = ' + fieldName + '!');
    }
    else if (isCastType(type)) {
      lines.push('guard let ' + name + ': ' + typeString + ' = ' + fieldName + '! as? ' + typeString + ' else {')
      lines.push('  assertionFailure("field \'' + name + '\' is not a ' + typeString + '")');
      lines.push('  return nil');
      lines.push('}');
    }
    else {
      lines.push('guard let ' + name + ': ' + typeString + ' = ' + decodeFunction(fieldName + '!', type, structTypeArguments) + ' else {')
      lines.push('  assertionFailure("field \'' + name + '\' is not a ' + typeString + '")');
      lines.push('  return nil');
      lines.push('}');
    }
  }

  lines.push('');

  return lines;
}

function makeReturn(struct: Struct) {
  var params = struct.varDecls.map(decl => decl.name + ': ' + decl.name);

  return 'return ' + struct.baseName + '(' + params.join(', ') + ')'
}

